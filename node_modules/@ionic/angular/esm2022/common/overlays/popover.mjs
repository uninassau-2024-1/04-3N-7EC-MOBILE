import { __decorate } from "tslib";
import { ContentChild, Directive, TemplateRef, } from '@angular/core';
import { ProxyCmp, proxyOutputs } from '../utils/proxy';
import * as i0 from "@angular/core";
const POPOVER_INPUTS = [
    'alignment',
    'animated',
    'arrow',
    'keepContentsMounted',
    'backdropDismiss',
    'cssClass',
    'dismissOnSelect',
    'enterAnimation',
    'event',
    'isOpen',
    'keyboardClose',
    'leaveAnimation',
    'mode',
    'showBackdrop',
    'translucent',
    'trigger',
    'triggerAction',
    'reference',
    'size',
    'side',
];
const POPOVER_METHODS = ['present', 'dismiss', 'onDidDismiss', 'onWillDismiss'];
let IonPopover = class IonPopover {
    z;
    // TODO(FW-2827): type
    template;
    isCmpOpen = false;
    el;
    constructor(c, r, z) {
        this.z = z;
        this.el = r.nativeElement;
        this.el.addEventListener('ionMount', () => {
            this.isCmpOpen = true;
            c.detectChanges();
        });
        this.el.addEventListener('didDismiss', () => {
            this.isCmpOpen = false;
            c.detectChanges();
        });
        proxyOutputs(this, this.el, [
            'ionPopoverDidPresent',
            'ionPopoverWillPresent',
            'ionPopoverWillDismiss',
            'ionPopoverDidDismiss',
            'didPresent',
            'willPresent',
            'willDismiss',
            'didDismiss',
        ]);
    }
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IonPopover, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Directive });
    /** @nocollapse */ static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.2.12", type: IonPopover, selector: "ion-popover", inputs: { alignment: "alignment", animated: "animated", arrow: "arrow", keepContentsMounted: "keepContentsMounted", backdropDismiss: "backdropDismiss", cssClass: "cssClass", dismissOnSelect: "dismissOnSelect", enterAnimation: "enterAnimation", event: "event", isOpen: "isOpen", keyboardClose: "keyboardClose", leaveAnimation: "leaveAnimation", mode: "mode", showBackdrop: "showBackdrop", translucent: "translucent", trigger: "trigger", triggerAction: "triggerAction", reference: "reference", size: "size", side: "side" }, queries: [{ propertyName: "template", first: true, predicate: TemplateRef, descendants: true }], ngImport: i0 });
};
IonPopover = __decorate([
    ProxyCmp({
        inputs: POPOVER_INPUTS,
        methods: POPOVER_METHODS,
    })
    /**
     * @Component extends from @Directive
     * so by defining the inputs here we
     * do not need to re-define them for the
     * lazy loaded popover.
     */
], IonPopover);
export { IonPopover };
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IonPopover, decorators: [{
            type: Directive,
            args: [{
                    selector: 'ion-popover',
                    // eslint-disable-next-line @angular-eslint/no-inputs-metadata-property
                    inputs: POPOVER_INPUTS,
                }]
        }], ctorParameters: function () { return [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.NgZone }]; }, propDecorators: { template: [{
                type: ContentChild,
                args: [TemplateRef, { static: false }]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG9wb3Zlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL2NvbW1vbi9zcmMvb3ZlcmxheXMvcG9wb3Zlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUVMLFlBQVksRUFDWixTQUFTLEVBSVQsV0FBVyxHQUNaLE1BQU0sZUFBZSxDQUFDO0FBR3ZCLE9BQU8sRUFBRSxRQUFRLEVBQUUsWUFBWSxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7O0FBcUN4RCxNQUFNLGNBQWMsR0FBRztJQUNyQixXQUFXO0lBQ1gsVUFBVTtJQUNWLE9BQU87SUFDUCxxQkFBcUI7SUFDckIsaUJBQWlCO0lBQ2pCLFVBQVU7SUFDVixpQkFBaUI7SUFDakIsZ0JBQWdCO0lBQ2hCLE9BQU87SUFDUCxRQUFRO0lBQ1IsZUFBZTtJQUNmLGdCQUFnQjtJQUNoQixNQUFNO0lBQ04sY0FBYztJQUNkLGFBQWE7SUFDYixTQUFTO0lBQ1QsZUFBZTtJQUNmLFdBQVc7SUFDWCxNQUFNO0lBQ04sTUFBTTtDQUNQLENBQUM7QUFFRixNQUFNLGVBQWUsR0FBRyxDQUFDLFNBQVMsRUFBRSxTQUFTLEVBQUUsY0FBYyxFQUFFLGVBQWUsQ0FBQyxDQUFDO0FBbUJ6RSxJQUFNLFVBQVUsR0FBaEIsTUFBTSxVQUFVO0lBUXNDO0lBUDNELHNCQUFzQjtJQUN3QixRQUFRLENBQW1CO0lBRXpFLFNBQVMsR0FBRyxLQUFLLENBQUM7SUFFUixFQUFFLENBQWM7SUFFMUIsWUFBWSxDQUFvQixFQUFFLENBQWEsRUFBWSxDQUFTO1FBQVQsTUFBQyxHQUFELENBQUMsQ0FBUTtRQUNsRSxJQUFJLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQyxhQUFhLENBQUM7UUFFMUIsSUFBSSxDQUFDLEVBQUUsQ0FBQyxnQkFBZ0IsQ0FBQyxVQUFVLEVBQUUsR0FBRyxFQUFFO1lBQ3hDLElBQUksQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDO1lBQ3RCLENBQUMsQ0FBQyxhQUFhLEVBQUUsQ0FBQztRQUNwQixDQUFDLENBQUMsQ0FBQztRQUNILElBQUksQ0FBQyxFQUFFLENBQUMsZ0JBQWdCLENBQUMsWUFBWSxFQUFFLEdBQUcsRUFBRTtZQUMxQyxJQUFJLENBQUMsU0FBUyxHQUFHLEtBQUssQ0FBQztZQUN2QixDQUFDLENBQUMsYUFBYSxFQUFFLENBQUM7UUFDcEIsQ0FBQyxDQUFDLENBQUM7UUFDSCxZQUFZLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxFQUFFLEVBQUU7WUFDMUIsc0JBQXNCO1lBQ3RCLHVCQUF1QjtZQUN2Qix1QkFBdUI7WUFDdkIsc0JBQXNCO1lBQ3RCLFlBQVk7WUFDWixhQUFhO1lBQ2IsYUFBYTtZQUNiLFlBQVk7U0FDYixDQUFDLENBQUM7SUFDTCxDQUFDOzJIQTdCVSxVQUFVOytHQUFWLFVBQVUsbW1CQUVQLFdBQVc7O0FBRmQsVUFBVTtJQWpCdEIsUUFBUSxDQUFDO1FBQ1IsTUFBTSxFQUFFLGNBQWM7UUFDdEIsT0FBTyxFQUFFLGVBQWU7S0FDekIsQ0FBQztJQUNGOzs7OztPQUtHO0dBUVUsVUFBVSxDQThCdEI7U0E5QlksVUFBVTs0RkFBVixVQUFVO2tCQVB0QixTQUFTO21CQUFDO29CQUNULFFBQVEsRUFBRSxhQUFhO29CQUN2Qix1RUFBdUU7b0JBQ3ZFLE1BQU0sRUFBRSxjQUFjO2lCQUN2QjtzSkFLK0MsUUFBUTtzQkFBckQsWUFBWTt1QkFBQyxXQUFXLEVBQUUsRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFFIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gIENvbnRlbnRDaGlsZCxcbiAgRGlyZWN0aXZlLFxuICBFbGVtZW50UmVmLFxuICBFdmVudEVtaXR0ZXIsXG4gIE5nWm9uZSxcbiAgVGVtcGxhdGVSZWYsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHR5cGUgeyBDb21wb25lbnRzIH0gZnJvbSAnQGlvbmljL2NvcmUvY29tcG9uZW50cyc7XG5cbmltcG9ydCB7IFByb3h5Q21wLCBwcm94eU91dHB1dHMgfSBmcm9tICcuLi91dGlscy9wcm94eSc7XG5cbmV4cG9ydCBkZWNsYXJlIGludGVyZmFjZSBJb25Qb3BvdmVyIGV4dGVuZHMgQ29tcG9uZW50cy5Jb25Qb3BvdmVyIHtcbiAgLyoqXG4gICAqIEVtaXR0ZWQgYWZ0ZXIgdGhlIHBvcG92ZXIgaGFzIHByZXNlbnRlZC5cbiAgICovXG4gIGlvblBvcG92ZXJEaWRQcmVzZW50OiBFdmVudEVtaXR0ZXI8Q3VzdG9tRXZlbnQ+O1xuICAvKipcbiAgICogRW1pdHRlZCBiZWZvcmUgdGhlIHBvcG92ZXIgaGFzIHByZXNlbnRlZC5cbiAgICovXG4gIGlvblBvcG92ZXJXaWxsUHJlc2VudDogRXZlbnRFbWl0dGVyPEN1c3RvbUV2ZW50PjtcbiAgLyoqXG4gICAqIEVtaXR0ZWQgYWZ0ZXIgdGhlIHBvcG92ZXIgaGFzIGRpc21pc3NlZC5cbiAgICovXG4gIGlvblBvcG92ZXJXaWxsRGlzbWlzczogRXZlbnRFbWl0dGVyPEN1c3RvbUV2ZW50PjtcbiAgLyoqXG4gICAqIEVtaXR0ZWQgYWZ0ZXIgdGhlIHBvcG92ZXIgaGFzIGRpc21pc3NlZC5cbiAgICovXG4gIGlvblBvcG92ZXJEaWREaXNtaXNzOiBFdmVudEVtaXR0ZXI8Q3VzdG9tRXZlbnQ+O1xuICAvKipcbiAgICogRW1pdHRlZCBhZnRlciB0aGUgcG9wb3ZlciBoYXMgcHJlc2VudGVkLiBTaG9ydGhhbmQgZm9yIGlvblBvcG92ZXJEaWRQcmVzZW50LlxuICAgKi9cbiAgZGlkUHJlc2VudDogRXZlbnRFbWl0dGVyPEN1c3RvbUV2ZW50PjtcbiAgLyoqXG4gICAqIEVtaXR0ZWQgYmVmb3JlIHRoZSBwb3BvdmVyIGhhcyBwcmVzZW50ZWQuIFNob3J0aGFuZCBmb3IgaW9uUG9wb3ZlcldpbGxQcmVzZW50LlxuICAgKi9cbiAgd2lsbFByZXNlbnQ6IEV2ZW50RW1pdHRlcjxDdXN0b21FdmVudD47XG4gIC8qKlxuICAgKiBFbWl0dGVkIGFmdGVyIHRoZSBwb3BvdmVyIGhhcyBwcmVzZW50ZWQuIFNob3J0aGFuZCBmb3IgaW9uUG9wb3ZlcldpbGxEaXNtaXNzLlxuICAgKi9cbiAgd2lsbERpc21pc3M6IEV2ZW50RW1pdHRlcjxDdXN0b21FdmVudD47XG4gIC8qKlxuICAgKiBFbWl0dGVkIGFmdGVyIHRoZSBwb3BvdmVyIGhhcyBkaXNtaXNzZWQuIFNob3J0aGFuZCBmb3IgaW9uUG9wb3ZlckRpZERpc21pc3MuXG4gICAqL1xuICBkaWREaXNtaXNzOiBFdmVudEVtaXR0ZXI8Q3VzdG9tRXZlbnQ+O1xufVxuXG5jb25zdCBQT1BPVkVSX0lOUFVUUyA9IFtcbiAgJ2FsaWdubWVudCcsXG4gICdhbmltYXRlZCcsXG4gICdhcnJvdycsXG4gICdrZWVwQ29udGVudHNNb3VudGVkJyxcbiAgJ2JhY2tkcm9wRGlzbWlzcycsXG4gICdjc3NDbGFzcycsXG4gICdkaXNtaXNzT25TZWxlY3QnLFxuICAnZW50ZXJBbmltYXRpb24nLFxuICAnZXZlbnQnLFxuICAnaXNPcGVuJyxcbiAgJ2tleWJvYXJkQ2xvc2UnLFxuICAnbGVhdmVBbmltYXRpb24nLFxuICAnbW9kZScsXG4gICdzaG93QmFja2Ryb3AnLFxuICAndHJhbnNsdWNlbnQnLFxuICAndHJpZ2dlcicsXG4gICd0cmlnZ2VyQWN0aW9uJyxcbiAgJ3JlZmVyZW5jZScsXG4gICdzaXplJyxcbiAgJ3NpZGUnLFxuXTtcblxuY29uc3QgUE9QT1ZFUl9NRVRIT0RTID0gWydwcmVzZW50JywgJ2Rpc21pc3MnLCAnb25EaWREaXNtaXNzJywgJ29uV2lsbERpc21pc3MnXTtcblxuQFByb3h5Q21wKHtcbiAgaW5wdXRzOiBQT1BPVkVSX0lOUFVUUyxcbiAgbWV0aG9kczogUE9QT1ZFUl9NRVRIT0RTLFxufSlcbi8qKlxuICogQENvbXBvbmVudCBleHRlbmRzIGZyb20gQERpcmVjdGl2ZVxuICogc28gYnkgZGVmaW5pbmcgdGhlIGlucHV0cyBoZXJlIHdlXG4gKiBkbyBub3QgbmVlZCB0byByZS1kZWZpbmUgdGhlbSBmb3IgdGhlXG4gKiBsYXp5IGxvYWRlZCBwb3BvdmVyLlxuICovXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICdpb24tcG9wb3ZlcicsXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAYW5ndWxhci1lc2xpbnQvbm8taW5wdXRzLW1ldGFkYXRhLXByb3BlcnR5XG4gIGlucHV0czogUE9QT1ZFUl9JTlBVVFMsXG59KVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQGFuZ3VsYXItZXNsaW50L2RpcmVjdGl2ZS1jbGFzcy1zdWZmaXhcbmV4cG9ydCBjbGFzcyBJb25Qb3BvdmVyIHtcbiAgLy8gVE9ETyhGVy0yODI3KTogdHlwZVxuICBAQ29udGVudENoaWxkKFRlbXBsYXRlUmVmLCB7IHN0YXRpYzogZmFsc2UgfSkgdGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG5cbiAgaXNDbXBPcGVuID0gZmFsc2U7XG5cbiAgcHJvdGVjdGVkIGVsOiBIVE1MRWxlbWVudDtcblxuICBjb25zdHJ1Y3RvcihjOiBDaGFuZ2VEZXRlY3RvclJlZiwgcjogRWxlbWVudFJlZiwgcHJvdGVjdGVkIHo6IE5nWm9uZSkge1xuICAgIHRoaXMuZWwgPSByLm5hdGl2ZUVsZW1lbnQ7XG5cbiAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ2lvbk1vdW50JywgKCkgPT4ge1xuICAgICAgdGhpcy5pc0NtcE9wZW4gPSB0cnVlO1xuICAgICAgYy5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgfSk7XG4gICAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKCdkaWREaXNtaXNzJywgKCkgPT4ge1xuICAgICAgdGhpcy5pc0NtcE9wZW4gPSBmYWxzZTtcbiAgICAgIGMuZGV0ZWN0Q2hhbmdlcygpO1xuICAgIH0pO1xuICAgIHByb3h5T3V0cHV0cyh0aGlzLCB0aGlzLmVsLCBbXG4gICAgICAnaW9uUG9wb3ZlckRpZFByZXNlbnQnLFxuICAgICAgJ2lvblBvcG92ZXJXaWxsUHJlc2VudCcsXG4gICAgICAnaW9uUG9wb3ZlcldpbGxEaXNtaXNzJyxcbiAgICAgICdpb25Qb3BvdmVyRGlkRGlzbWlzcycsXG4gICAgICAnZGlkUHJlc2VudCcsXG4gICAgICAnd2lsbFByZXNlbnQnLFxuICAgICAgJ3dpbGxEaXNtaXNzJyxcbiAgICAgICdkaWREaXNtaXNzJyxcbiAgICBdKTtcbiAgfVxufVxuIl19